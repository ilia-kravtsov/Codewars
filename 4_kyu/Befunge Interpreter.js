/*
Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!

Your task is to write a method which will interpret Befunge-93 code! Befunge-93 is a language in which the code is presented not as a series of instructions, but as instructions scattered on a 2D plane; your pointer starts at the top-left corner and defaults to moving right through the code. Note that the instruction pointer wraps around the screen! There is a singular stack which we will assume is unbounded and only contain integers. While Befunge-93 code is supposed to be restricted to 80x25, you need not be concerned with code size. Befunge-93 supports the following instructions (from Wikipedia):

0-9 Push this number onto the stack.
+ Addition: Pop a and b, then push a+b.
- Subtraction: Pop a and b, then push b-a.
* Multiplication: Pop a and b, then push a*b.
/ Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
% Modulo: Pop a and b, then push the b%a. If a is zero, push zero.
! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
` (backtick) Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
> Start moving right.
< Start moving left.
^ Start moving up.
v Start moving down.
? Start moving in a random cardinal direction.
_ Pop a value; move right if value = 0, left otherwise.
| Pop a value; move down if value = 0, up otherwise.
" Start string mode: push each character's ASCII value all the way up to the next ".
: Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
\ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
$ Pop value from the stack and discard it.
. Pop value and output as an integer.
, Pop value and output the ASCII character represented by the integer code that is stored in the value.
# Trampoline: Skip next cell.
p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.
g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.
@ End program.
  (i.e. a space) No-op. Does nothing.
The above list is slightly modified: you'll notice if you look at the Wikipedia page that we do not use the user input instructions and dividing by zero simply yields zero.

Here's an example:

>987v>.v
v456<  :
>321 ^ _@
will create the output 123456789.

So what you must do is create a function such that when you pass in the Befunge code, the function returns the output that would be generated by the code. So, for example:

"123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456<  :\n>321 ^ _@")
This test case will be added for you.
*/

function interpret(code) {
  let lines = code.split("\n");
  const rows = lines.length;
  const cols = Math.max(...lines.map((line) => line.length));
  let grid = [];
  for (let y = 0; y < rows; y++) {
    grid[y] = lines[y].padEnd(cols, " ").split("");
  }

  let x = 0,
    y = 0,
    dx = 1,
    dy = 0;
  let output = "";
  let stack = [];
  let stringMode = false;

  function popStack() {
    return stack.length ? stack.pop() : 0;
  }
  function pushStack(val) {
    stack.push(val);
  }

  while (true) {
    let instruction = grid[y][x];

    if (stringMode && instruction !== '"') {
      pushStack(instruction.charCodeAt(0));
    } else {
      switch (instruction) {
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          pushStack(parseInt(instruction, 10));
          break;

        case "+": {
          let a = popStack(),
            b = popStack();
          pushStack(b + a);
          break;
        }
        case "-": {
          let a = popStack(),
            b = popStack();
          pushStack(b - a);
          break;
        }
        case "*": {
          let a = popStack(),
            b = popStack();
          pushStack(b * a);
          break;
        }
        case "/": {
          let a = popStack(),
            b = popStack();
          pushStack(a === 0 ? 0 : Math.floor(b / a));
          break;
        }
        case "%": {
          let a = popStack(),
            b = popStack();
          pushStack(a === 0 ? 0 : b % a);
          break;
        }
        case "!": {
          let a = popStack();
          pushStack(a === 0 ? 1 : 0);
          break;
        }
        case "`": {
          let a = popStack(),
            b = popStack();
          pushStack(b > a ? 1 : 0);
          break;
        }
        case ">":
          dx = 1;
          dy = 0;
          break;
        case "<":
          dx = -1;
          dy = 0;
          break;
        case "^":
          dx = 0;
          dy = -1;
          break;
        case "v":
          dx = 0;
          dy = 1;
          break;
        case "?": {
          const dirs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ];
          [dx, dy] = dirs[Math.floor(Math.random() * 4)];
          break;
        }
        case "_": {
          let a = popStack();
          if (a === 0) {
            dx = 1;
            dy = 0;
          } else {
            dx = -1;
            dy = 0;
          }
          break;
        }
        case "|": {
          let a = popStack();
          if (a === 0) {
            dx = 0;
            dy = 1;
          } else {
            dx = 0;
            dy = -1;
          }
          break;
        }
        case '"':
          stringMode = !stringMode;
          break;
        case ":": {
          let a = popStack();
          pushStack(a);
          pushStack(a);
          break;
        }
        case "\\": {
          let a = popStack(),
            b = popStack();
          pushStack(a);
          pushStack(b);
          break;
        }
        case "$":
          popStack();
          break;
        case ".": {
          let a = popStack();
          output += a.toString();
          break;
        }
        case ",": {
          let a = popStack();
          output += String.fromCharCode(a);
          break;
        }
        case "#":
          x = (x + dx + cols) % cols;
          y = (y + dy + rows) % rows;
          break;
        case "p": {
          let yPos = popStack();
          let xPos = popStack();
          let v = popStack();
          if (yPos >= 0 && yPos < rows && xPos >= 0 && xPos < cols) {
            grid[yPos][xPos] = String.fromCharCode(v);
          }
          break;
        }
        case "g": {
          let yPos = popStack();
          let xPos = popStack();
          if (yPos >= 0 && yPos < rows && xPos >= 0 && xPos < cols) {
            pushStack(grid[yPos][xPos].charCodeAt(0));
          } else {
            pushStack(0);
          }
          break;
        }
        case "@":
          return output;
        case " ":
          break;
        default:
          break;
      }
    }

    x = (x + dx + cols) % cols;
    y = (y + dy + rows) % rows;
  }
}
