<h2><a href=https://www.codewars.com/kata/53c2502d1dfa43f6420001e6/train/javascript target="_blank">Lazy evaluation</a></h2><h3>5 kyu</h3><p><a href="http://en.wikipedia.org/wiki/Lazy_evaluation" data-turbolinks="false" target="_blank">Lazy evaluation</a> is an evaluation strategy which delays the evaluation of an expression until its value is needed.</p><p>Implement the <em>Lazy function</em>. This function has two methods:</p><ul><li><code>add(fn[, arg1, arg2, ...])</code>: adds the <em>fn</em> function to the lazy chain evaluation. This function could receive optional arguments.</li><li><code>invoke(target)</code>: performs the evaluation chain over the <em>target</em> array.</li></ul><p>For example:</p><p>Given these functions:</p><pre><code class="language-javascript"><span class="cm-keyword">function</span> <span class="cm-def">max</span>() {    <span class="cm-keyword">return</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>.<span class="cm-property">apply</span>(<span class="cm-atom">null</span>, <span class="cm-variable-2">arguments</span>);}<span class="cm-keyword">function</span> <span class="cm-def">filterNumbers</span>() {  <span class="cm-keyword">return</span> <span class="cm-variable">Array</span>.<span class="cm-property">prototype</span>.<span class="cm-property">filter</span>.<span class="cm-property">call</span>(<span class="cm-variable-2">arguments</span>, <span class="cm-keyword">function</span>(<span class="cm-def">value</span>) {    <span class="cm-keyword">return</span> <span class="cm-variable">isNumeric</span>(<span class="cm-variable-2">value</span>);  });}<span class="cm-keyword">function</span> <span class="cm-def">isNumeric</span>(<span class="cm-def">n</span>) {  <span class="cm-keyword">return</span> <span class="cm-operator">!</span><span class="cm-variable">isNaN</span>(<span class="cm-variable-2">n</span>) <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable">Number</span>(<span class="cm-variable-2">n</span>) <span class="cm-operator">===</span> <span class="cm-variable-2">n</span>;}<span class="cm-keyword">function</span> <span class="cm-def">filterRange</span>(<span class="cm-def">min</span>, <span class="cm-def">max</span>) {  <span class="cm-keyword">var</span> <span class="cm-def">args</span> <span class="cm-operator">=</span> <span class="cm-variable">Array</span>.<span class="cm-property">prototype</span>.<span class="cm-property">slice</span>.<span class="cm-property">call</span>(<span class="cm-variable-2">arguments</span>, <span class="cm-number">2</span>);  <span class="cm-keyword">return</span> <span class="cm-variable">Array</span>.<span class="cm-property">prototype</span>.<span class="cm-property">filter</span>.<span class="cm-property">call</span>(<span class="cm-variable-2">args</span>, <span class="cm-keyword">function</span>(<span class="cm-def">value</span>) {    <span class="cm-keyword">return</span> <span class="cm-variable-2">min</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable-2">value</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable-2">value</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable-2">max</span>;  });}</code></pre><p>You could use it via composition:</p><pre><code class="language-javascript"><span class="cm-variable">max</span>.<span class="cm-property">apply</span>(<span class="cm-atom">null</span>, <span class="cm-variable">filterRange</span>.<span class="cm-property">apply</span>(<span class="cm-atom">null</span>, [<span class="cm-number">1</span>, <span class="cm-number">3</span>].<span class="cm-property">concat</span>(<span class="cm-variable">filterNumbers</span>(<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-string">"3"</span>, <span class="cm-number">7</span>, <span class="cm-number">6</span>, <span class="cm-number">5</span>))));</code></pre><p>But this solution is not reusable. </p><p>A better approach could be to use composition with lazy invocation:</p><pre><code class="language-javascript"><span class="cm-keyword">new</span> <span class="cm-variable">Lazy</span>()      .<span class="cm-property">add</span>(<span class="cm-variable">filterNumbers</span>)      .<span class="cm-property">add</span>(<span class="cm-variable">filterRange</span>, <span class="cm-number">2</span>, <span class="cm-number">7</span>)      .<span class="cm-property">add</span>(<span class="cm-variable">max</span>)      .<span class="cm-property">invoke</span>([<span class="cm-number">1</span>, <span class="cm-number">8</span>, <span class="cm-number">6</span>, [], <span class="cm-string">"7"</span>, <span class="cm-operator">-</span><span class="cm-number">1</span>, {<span class="cm-property">v</span>: <span class="cm-number">5</span>}, <span class="cm-number">4</span>]); <span class="cm-comment">//6</span></code></pre><p>Step by step, this is what should happen when <em>invoke</em> function is called:</p><pre><code>filterNumbers(1, 8, 6, [], "7", -1, {v: 5}, 4) // == [1, 8, 6, -1, 4]//            ^------------------------------ from invokefilterRange(2, 7, 1, 8, 6, -1, 4) // == [6, 4]// from add ---^  ^------------- from previous resultmax(6, 4) // == 6//  ^--- from previous resultResult from invoke: 6//                  ^ from last result</code></pre>