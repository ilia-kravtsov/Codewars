<h2><a href=https://www.codewars.com/kata/53381a646068efc50100072c/train/javascript target="_blank">Function.prototype.clone</a></h2><h3>5 kyu</h3><p>Without using eval, write a clone method to clone a function's arguments and body into a new function. You don't have to worry about the <code>name</code> of the function; it's impossible to override that property of a function.</p><pre><code class="language-javascript"><span class="cm-keyword">var</span> <span class="cm-def">original</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span> <span class="cm-def">original_name</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>; };<span class="cm-keyword">var</span> <span class="cm-def">cloned</span> <span class="cm-operator">=</span> <span class="cm-variable">o</span>.<span class="cm-property">clone</span>();<span class="cm-comment">// cloned == function(a, b) { return a + b; }</span></code></pre><p>So the new cloned function is a completely new object, with its own scope, but effectively behaves the exact same way as the original function.</p><blockquote><p><strong>NOTE:</strong> This kata focuses on ES5 only (<code>function fn() {}</code>), but you get bonus points for making your solution ES6 compatible (<code>fn = (a, b) =&gt; a + b</code>)!</p></blockquote>