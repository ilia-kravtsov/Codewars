<h2><a href=https://www.codewars.com/kata/5a2c343e8f27f2636c0000c9/train/javascript target="_blank">Dynamic Programming #1: Shortest Path in a Weighted DAG</a></h2><h3>5 kyu</h3><h2 id="tldr">TL;DR</h2><p>Given a number of vertices <code>N</code> and a list of weighted directed edges in a directed acyclic graph (each edge is written as <code>[start, end, weight]</code> where <code>start &lt; end</code>), compute the weight of the shortest path from vertex <code>0</code> to vertex <code>N - 1</code>.  If there is no such path, return <code>-1</code>.</p><h2 id="background">Background</h2><p>A weighted DAG is a directed acyclic graph where each edge has a weight associated with it:</p><center><img src="https://user-content.gitter-static.net/620f5472c30df891a57e0277f083a518e7d80ab8/68747470733a2f2f66696c65732e6769747465722e696d2f3535613663643136356530643531626437383762376433362f445948702f7468756d622f696d6167652e706e67"> </center><p>In this example, the shortest path from A to D is given by A -&gt; B -&gt; D, which has a total weight of 4.</p><p>Finding shortest distances in DAGs is made easier by the fact that the nodes can be <em>linearized:</em> they can be given an order <code>A1, A2, ..., An</code> such that edges only point forward (that is, there are no edges from <code>Aj</code> to <code>Ai</code> when <code>j &gt; i</code>).  In the example above, the two possible linear orderings are <code>A, B, C, D</code> and <code>A, C, B, D.</code></p><center><img src="https://user-content.gitter-static.net/d1a4ab722c19c3f2f644d6ba8562d3f854953ee4/68747470733a2f2f66696c65732e6769747465722e696d2f3535613663643136356530643531626437383762376433362f51726e532f7468756d622f696d6167652e706e67"></center><h2 id="your-task">Your Task</h2><p>Given a number <code>N</code> (indicating a graph with vertices <code>0, 1, ..., N-1</code>) and a list of weighted edges <code>[start, end, weight]</code> for a DAG, where <code>start &lt; end</code> for each edge, find the weight (a.k.a. length) of the shortest path from node <code>0</code> to node <code>N-1</code>.</p><p>For example, if the input is</p><pre><code>N = 4edgeList = [  [0, 1, 1], [0, 2, 5], [0, 3, 5], [1, 3, 3], [2, 3, 1]]</code></pre><p>then we have the graph depicted above (with <code>0 = A</code>, <code>1 = B</code>, etc.) and the answer is <code>4</code>.</p><p>If there is no path from node <code>0</code> to node <code>N-1</code>, return <code>-1</code> (or <code>Nothing</code>).</p><h2 id="notes-and-warnings">Notes and Warnings</h2><p><strong>Precondition:</strong> <code>N</code> will always be greater than 1, and edge weights will always be positive integers.  There may be multiple edges going between two nodes.</p><p><strong>Warning:</strong> You will probably need to use a dynamic programming solution if you want your solution to run fast enough not to time out--that's the whole point of this kata!</p><p>However, a well-written general shortest-path algorithm such as Dijkstra's Algorithm may also be fast enough to past the soak tests.  (The reason is that the dividing line between linear and linearithmic time is hard to define and depends on a variety of external factors, so the kata's tests err on the safe side.)</p>